package com.server;

import static com.server.KNTServer.PLAYERS;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import com.model.Game;
import com.model.GameRoom;
import com.model.Player;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Notification;

public class KNTServer {
	private static final ServerSocket SERVER;
	// TODO Move me to a common class so that client and server can use me.
	private static final ExecutorService THREAD_POOL;
	
	/** Maps players to their connection handlers. */
	static final Map<String, PlayerConnection> PLAYERS;
	static final Map<String, GameRoom> GAME_ROOMS;
	/** Notifications generated by the request with UUID. */
//	static final Map<UUID, List<JSONRPC2Notification>> PENDING_NOTIFICATIONS;
	// It does not make sense to keep Game in GameRoom on the client side.
	// Track game instances here.
//	static final Map<String, Game> GAMES;
	
	// TODO Need to handle client disconnections and thread pool cleanup
	static {
		THREAD_POOL = Executors.newFixedThreadPool(200);
		
		ServerSocket server = null;
		try {
			server = new ServerSocket(6868);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		PLAYERS = Collections.synchronizedMap(new HashMap<String, PlayerConnection>());
		GAME_ROOMS = Collections.synchronizedMap(new HashMap<String, GameRoom>());
//		PENDING_NOTIFICATIONS = Collections.synchronizedMap(new HashMap<UUID, List<JSONRPC2Notification>>());
		
		SERVER = server;
	}
	
	public void listen() throws IOException, InterruptedException {
		System.out.println("Server listening on port 6868");
		while (true) {
			Socket playerSocket = SERVER.accept();
			
			System.out.println("Client connected: " + playerSocket.getInetAddress().getHostAddress());

			PlayerConnection connection = new PlayerConnection(playerSocket);
			connection.startOn(THREAD_POOL);

		}
	}
	
	public static void notifyAllClients(GameRoom room, JSONRPC2Notification notification) {
		synchronized (PLAYERS) {
			PLAYERS.get(room.getHost().getName()).notifyClient(notification);
			
			for (Player p : room.getPlayers()) {
				PLAYERS.get(p.getName()).notifyClient(notification);
			}
		}
	}
	
	public static void notifyOtherClients(ServerGameRoom room, JSONRPC2Notification notification, Player exclude) {
		// Exclude notifying playerName
		if (!room.getHost().getName().equals(exclude.getName())) {
			synchronized (PLAYERS) {
				PLAYERS.get(room.getHost().getName()).notifyClient(notification);
			}
		}
		
		synchronized (PLAYERS) {
			for (Player p : room.getPlayers()) {
				if (!p.getName().equals(exclude.getName())) {
						PLAYERS.get(p.getName()).notifyClient(notification);			
				}
			}
		}
	}
	
	//TODO: KNTServer#shutdown()
	
	public static void main(String[] args) throws IOException, InterruptedException {
		KNTServer server = new KNTServer();
		
		server.listen();
	}
}